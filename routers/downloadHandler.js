const express = require('express')
const router = express.Router()
const tokenVerifier = require("../verifiers/token")
const uploadPath = "./photos/uploads/"
const liteUploadPath = "./photos/lite-photos/"
const fs = require('fs')
const photoDatabase = require("../databases/photoDatabase")
const AdmZip = require('adm-zip')
const archiver = require("archiver")
const downloadTokenMap = new Map()

/*
manages download of whole gallery
*/
router.post("/photo-gallery/download-whole-gallery", async function (request, response) {
    let token = request.cookies.token
    if (!tokenVerifier.isTokenValid(token, response)) {
        return
    }
    const galleryID = request.body.galleryID
    const version = request.body.version
    tokenVerifier.refreshToken(token, response)
    const gallery = await photoDatabase.findGalleryByID(galleryID)

    response.setHeader('Content-Disposition', 'attachment; filename=' + gallery.galleryTitle + "-" + version + ".zip");
    createZipFromArray(gallery.photos, version, response)

})
/*
manages download of separated photos by download token generated by function
*/
router.get("/download/photos", async function (request, response) {
    let token = request.cookies.token
    if (!tokenVerifier.isTokenValid(token, response)) {
        return
    }
    const downloadToken = request.query.downloadToken
    if (downloadTokenMap.has(downloadToken)) {
        const data = downloadTokenMap.get(downloadToken)
        downloadTokenMap.delete(downloadToken)
        response.setHeader('Content-Disposition', 'attachment; filename=eForcePhotos-' + data.photos.length + "-" + data.version + '.zip')
        createZipFromArray(data.photos, data.version, response)
    } else {
        response.send("")
    }

})

/*
generates download token for photos download, saves download token in map, where it is later picked and deleted
also saves photos, version into map to download it
*/
router.post("/download/generate-token-for-download", async function (request, response) {
    let token = request.cookies.token
    if (!tokenVerifier.isTokenValid(token, response)) {
        return
    }
    tokenVerifier.refreshToken(token, response)
    const body = request.body
    const downloadToken = generateRandomToken(64)
    const data = {
        photos: body.allPhotos ? await photoDatabase.getAllPhotos(body.photos, true) : body.photos,
        version: body.version
    }
    downloadTokenMap.set(downloadToken, data)
    response.json({
        downloadToken: downloadToken
    })
})

/*
generates random string by param length
*/
function generateRandomToken(length) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    let token = ""
    for (let i = 0; i < length; i++) {
        token += chars[Math.floor(Math.random() * chars.length)]
    }
    return token
}



/*
archives photos list on the fly and send is to the client
*/
async function createZipFromArray(array, version, response) {
    console.log(array)
    const archive = archiver("zip", {
        store: true
    })
    archive.pipe(response)
    for (const photo of array) {
        let file = version === "full" ? uploadPath : liteUploadPath
        file += photo
        archive.append(fs.createReadStream(file), {
            name: photo
        })
    }
    archive.finalize()
    archive.on("end", () => {
        response.end()
    })
}


module.exports = router