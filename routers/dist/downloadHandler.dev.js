"use strict";

var express = require('express');

var router = express.Router();

var tokenVerifier = require("../verifiers/token");

var uploadPath = "./photos/uploads/";
var liteUploadPath = "./photos/lite-photos/";

var fs = require('fs');

var photoDatabase = require("../databases/photoDatabase");

var AdmZip = require('adm-zip');

var archiver = require("archiver");

var downloadTokenMap = new Map();

var databaseHelper = require("../databases/databaseHelpers");
/*
manages download of whole gallery
*/


router.post("/eforce-gallery/photo-gallery/download-whole-gallery", function _callee(request, response) {
  var token, galleryID, version, gallery;
  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          token = request.cookies.token;

          if (tokenVerifier.isTokenValid(token, response)) {
            _context.next = 3;
            break;
          }

          return _context.abrupt("return");

        case 3:
          galleryID = request.body.galleryID;
          version = request.body.version;
          tokenVerifier.refreshToken(token, response);
          _context.next = 8;
          return regeneratorRuntime.awrap(photoDatabase.findGalleryByID(galleryID));

        case 8:
          gallery = _context.sent;
          response.setHeader('Content-Disposition', 'attachment; filename=' + databaseHelper.stringToEnglish(gallery.galleryTitle) + "-" + version + ".zip");
          createZipFromArray(gallery.photos, version, response);

        case 11:
        case "end":
          return _context.stop();
      }
    }
  });
});
/*
manages download of separated photos by download token generated by function
*/

router.get("/eforce-gallery/download/photos", function _callee2(request, response) {
  var token, downloadToken, data;
  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          token = request.cookies.token;

          if (tokenVerifier.isTokenValid(token, response)) {
            _context2.next = 3;
            break;
          }

          return _context2.abrupt("return");

        case 3:
          downloadToken = request.query.downloadToken;

          if (downloadTokenMap.has(downloadToken)) {
            data = downloadTokenMap.get(downloadToken);
            downloadTokenMap["delete"](downloadToken);
            response.setHeader('Content-Disposition', 'attachment; filename=eForcePhotos-' + data.photos.length + "-" + data.version + '.zip');
            createZipFromArray(data.photos, data.version, response);
          } else {
            response.send("");
          }

        case 5:
        case "end":
          return _context2.stop();
      }
    }
  });
});
/*
generates download token for photos download, saves download token in map, where it is later picked and deleted
also saves photos, version into map to download it
*/

router.post("/eforce-gallery/download/generate-token-for-download", function _callee3(request, response) {
  var token, body, downloadToken, data;
  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          token = request.cookies.token;

          if (tokenVerifier.isTokenValid(token, response)) {
            _context3.next = 3;
            break;
          }

          return _context3.abrupt("return");

        case 3:
          tokenVerifier.refreshToken(token, response);
          body = request.body;
          downloadToken = generateRandomToken(64);

          if (!body.allPhotos) {
            _context3.next = 12;
            break;
          }

          _context3.next = 9;
          return regeneratorRuntime.awrap(photoDatabase.getAllPhotos(body.photos, true));

        case 9:
          _context3.t0 = _context3.sent;
          _context3.next = 13;
          break;

        case 12:
          _context3.t0 = body.photos;

        case 13:
          _context3.t1 = _context3.t0;
          _context3.t2 = body.version;
          data = {
            photos: _context3.t1,
            version: _context3.t2
          };
          downloadTokenMap.set(downloadToken, data);
          response.json({
            downloadToken: downloadToken
          });

        case 18:
        case "end":
          return _context3.stop();
      }
    }
  });
});
/*
generates random string by param length
*/

function generateRandomToken(length) {
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  var token = "";

  for (var i = 0; i < length; i++) {
    token += chars[Math.floor(Math.random() * chars.length)];
  }

  return token;
}
/*
archives photos list on the fly and send is to the client
*/


function createZipFromArray(array, version, response) {
  var archive, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, photo, file;

  return regeneratorRuntime.async(function createZipFromArray$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          console.log(array);
          archive = archiver("zip", {
            store: true
          });
          archive.pipe(response);
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context4.prev = 6;

          for (_iterator = array[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            photo = _step.value;
            file = version === "full" ? uploadPath : liteUploadPath;
            file += photo;
            archive.append(fs.createReadStream(file), {
              name: photo
            });
          }

          _context4.next = 14;
          break;

        case 10:
          _context4.prev = 10;
          _context4.t0 = _context4["catch"](6);
          _didIteratorError = true;
          _iteratorError = _context4.t0;

        case 14:
          _context4.prev = 14;
          _context4.prev = 15;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 17:
          _context4.prev = 17;

          if (!_didIteratorError) {
            _context4.next = 20;
            break;
          }

          throw _iteratorError;

        case 20:
          return _context4.finish(17);

        case 21:
          return _context4.finish(14);

        case 22:
          archive.finalize();
          archive.on("end", function () {
            response.end();
          });

        case 24:
        case "end":
          return _context4.stop();
      }
    }
  }, null, null, [[6, 10, 14, 22], [15,, 17, 21]]);
}

module.exports = router;